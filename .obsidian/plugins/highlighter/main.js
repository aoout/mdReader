/** GENERATED BY OBSIDIAN-PLUGIN-CLI, DO NOT EDIT */
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/main.ts
__export(exports, {
  default: () => HighlighterPlugin
});
var import_obsidian4 = __toModule(require("obsidian"));

// src/settings/settings.ts
var DEFAULT_SETTINGS = {
  boxTags: ["HighlightBox"],
  boxType: "MOC"
};

// src/lib/HighlightBox.ts
var import_obsidian = __toModule(require("obsidian"));

// src/lib/getHighlights.ts
function getHighlights(content, sourcePath) {
  const highlights = [];
  const regex = /==(.+)==/g;
  let match = null;
  while ((match = regex.exec(content)) !== null) {
    highlights.push({
      content: match[1],
      sourcePath
    });
  }
  return highlights;
}

// src/lib/HighlightBox.ts
var path = __toModule(require("path"));
var HighlightBox = class {
  constructor(app, path3) {
    this.app = app;
    this.path = path3;
  }
  static type(type) {
    if (type == "MOC")
      return MocBox;
    if (type == "Folder")
      return FolderBox;
    throw new Error("Invalid type");
  }
  static tagCheck(app, path3, boxTags) {
    const tags = app.metadataCache.getCache(path3)?.frontmatter?.tags || [];
    return tags.some((tag) => boxTags.includes(tag));
  }
  async getHighlights() {
    const notes = this.getNotes();
    const highlights = [];
    return new Promise((resolve, _reject) => {
      for (const note of notes) {
        this.app.vault.cachedRead(note).then((content) => {
          const highlightsInNote = getHighlights(content, note.path);
          highlights.push(...highlightsInNote);
        });
      }
      resolve(highlights);
    });
  }
  getNotes() {
    throw new Error("Method not implemented.");
  }
};
var MocBox = class extends HighlightBox {
  static findBox(app, path3, boxTags) {
    const file = app.vault.getAbstractFileByPath(path3);
    if (!file || !(file instanceof import_obsidian.TFile))
      return;
    const backlinks = app.metadataCache.getBacklinksForFile(file);
    const result = Object.keys(backlinks.data).find((path4) => this.tagCheck(app, path4, boxTags));
    return new MocBox(app, result);
  }
  getNotes() {
    const notes = this.app.metadataCache.getCache(this.path).links.map((link) => {
      const file = this.app.vault.getAbstractFileByPath(link.link + ".md");
      if (!file)
        return;
      return file;
    });
    return notes;
  }
};
var FolderBox = class extends HighlightBox {
  static findBox(app, _path, boxTags) {
    const dir = path.dirname(_path);
    const folderNote = dir + "/" + path.basename(dir) + ".md";
    if (this.tagCheck(app, folderNote, boxTags))
      return new FolderBox(app, folderNote);
    if (dir == ".")
      return;
    return FolderBox.findBox(app, dir, boxTags);
  }
  getNotes() {
    const dir = path.dirname(this.path);
    const files = this.app.vault.getMarkdownFiles().filter((file) => file.path.split("/").includes(dir));
    return files;
  }
};

// src/HighlighterModal.ts
var import_obsidian2 = __toModule(require("obsidian"));
var HighlighterModal = class extends import_obsidian2.SuggestModal {
  constructor(app, highlights, choosed) {
    super(app);
    this.emptyStateText = "No highlight files found.";
    this.highlighters = highlights;
    this.choosed = choosed;
  }
  getSuggestions(query) {
    return this.highlighters.filter((highlight3) => highlight3.content.includes(query));
  }
  renderSuggestion(item, el) {
    el.createEl("div", { text: item.sourcePath });
    el.createEl("small", { text: item.content });
  }
  onChooseSuggestion(item, _evt) {
    this.choosed(item);
  }
};

// src/settings/settingsTab.ts
var import_obsidian3 = __toModule(require("obsidian"));
var HighlighterSettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Tags").setDesc("The tags that will be added to the imported books.").addText((text) => text.setPlaceholder("HighlighterBox").setValue(this.plugin.settings.boxTags.join(", ")).onChange(async (value) => {
      this.plugin.settings.boxTags = value.split(",").map((tag) => tag.trim());
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("HighlighterBox Type").setDesc("The type of the HighlighterBox that will be used.").addDropdown((text) => text.addOptions({
      Folder: "Folder",
      MOC: "MOC"
    }).setValue(this.plugin.settings.boxType).onChange(async (value) => {
      this.plugin.settings.boxType = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/main.ts
var import_path = __toModule(require("path"));

// src/lib/highlightsBuilder.ts
var HighlightsBuilder = class {
  static highlights2map(highlights) {
    const map = new Map();
    highlights.forEach((highlight3) => {
      const { sourcePath, content } = highlight3;
      const title = sourcePath.split("/").splice(-1)[0].split(".md")[0];
      const note = map.get(title);
      if (note) {
        note.push({ content, Comment: "" });
      } else {
        map.set(title, [{ content, Comment: "" }]);
      }
    });
    return map;
  }
  static map2markdown(map) {
    let markdown = "";
    map.forEach((value, key) => {
      markdown += `## ${key}

`;
      value.forEach((item) => {
        markdown += `${item.content}
`;
        if (item.comment) {
          markdown += `@
${item.comment}
`;
        }
        markdown += "\n";
      });
    });
    return markdown;
  }
  static markdown2map(markdown) {
    const map = new Map();
    const notes = markdown.split("## ").splice(1);
    notes.forEach((note) => {
      const title = note.split("\n")[0];
      const highlights = note.split("\n\n").splice(1).filter((highlight3) => highlight3);
      const items = [];
      highlights.forEach((highlight3) => {
        const content = highlight3.split("\n")[0];
        const comment = highlight3.split(content).splice(1).join("\n").split("@\n")[1];
        items.push({
          content,
          comment
        });
      });
      map.set(title, items);
    });
    return map;
  }
  static mergeComments(mapOld, mapNew) {
    return new Map(Array.from(mapNew.entries()).map((i) => [
      i[0],
      i[1].map((j) => ({
        content: j.content,
        comment: mapOld.get(i[0])?.find((i2) => i2.content == j.content)?.comment || ""
      }))
    ]));
  }
};

// src/main.ts
var HighlighterPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    console.log("Plugin Highlighter loaded.");
    await this.loadSettings();
    this.addSettingTab(new HighlighterSettingsTab(this.app, this));
    this.addCommand({
      id: "search-highlights-in-current-note",
      name: "Search highlights in current note",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile)
          return false;
        if (checking)
          return true;
        this.app.vault.cachedRead(activeFile).then((content) => {
          const highlights = getHighlights(content, activeFile.path);
          new HighlighterModal(this.app, highlights, (highlight3) => {
            this.jumpToHighlight(highlight3);
          }).open();
        });
        return true;
      }
    });
    this.addCommand({
      id: "search-highlights-in-current-HighlightBox",
      name: "Search highlights in current HighlightBox",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile)
          return false;
        const box = HighlightBox.type(this.settings.boxType).findBox(this.app, activeFile.path, this.settings.boxTags);
        if (!box)
          return false;
        if (checking)
          return true;
        box.getHighlights().then((highlights) => {
          new HighlighterModal(this.app, highlights, (highlight3) => {
            this.jumpToHighlight(highlight3);
          }).open();
        });
        return true;
      }
    });
    this.addCommand({
      id: "update-highlights-file",
      name: "Update highlights file",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile)
          return false;
        const box = HighlightBox.type(this.settings.boxType).findBox(this.app, activeFile.path, this.settings.boxTags);
        if (!box)
          return false;
        if (checking)
          return true;
        const folder = import_path.default.dirname(box.path);
        const highlightsPath = folder + "/highlights.md";
        const highlightsFile = this.app.vault.getAbstractFileByPath(highlightsPath);
        box.getHighlights().then((highlights) => {
          const map = HighlightsBuilder.highlights2map(highlights);
          if (!highlightsFile) {
            this.app.vault.create(highlightsPath, HighlightsBuilder.map2markdown(map));
          } else {
            this.app.vault.read(highlightsFile).then((content) => {
              const mapOld = HighlightsBuilder.markdown2map(content);
              const mapNew = HighlightsBuilder.mergeComments(mapOld, map);
              this.app.vault.modify(highlightsFile, HighlightsBuilder.map2markdown(mapNew));
            });
          }
        });
        return true;
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  jumpToHighlight(highlight3) {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile)
      return;
    if (activeFile.path != highlight3.sourcePath) {
      const file = this.app.vault.getAbstractFileByPath(highlight3.sourcePath);
      if (!file || !(file instanceof import_obsidian4.TFile))
        return;
      this.app.workspace.getLeaf().openFile(file).then(() => {
        this.jumpToContent(highlight3.content);
      });
    } else {
      this.jumpToContent(highlight3.content);
    }
  }
  jumpToContent(content) {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile)
      return;
    this.app.vault.cachedRead(activeFile).then((content2) => {
      const editor = this.app.workspace.activeEditor.editor;
      const st = content2.indexOf(content);
      const ed = st + content.length;
      const range = {
        from: editor.offsetToPos(st),
        to: editor.offsetToPos(ed)
      };
      editor.scrollIntoView(range, true);
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
